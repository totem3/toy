### 二分木を使った辞書を実装

最初commit logを真面目に書いて振り返れるようにしようと思ってたのに忘れてた

二分探索木を使った辞書を書いた。木はAVL木


#### 経緯

元々は最近Cを読む機会が増えて、（必要に迫られてというよりはなんとなくだけどapacheとかミドルウェアを読んでた）Cがイマイチよくわからないと思ってきた。

色々考えながら書いてみないとよくわからんなということでとりあえずCで何かを書ければ何でも良かった。

redis を読んでて dict.c を見かけて辞書でも書いてみるか、と思ったという謎の流れ。

で、書いた。

アルゴリズムとデータ構造超大事なわけなんだけど、今までも本とか読んでてなんとなくわかったつもりにはなっていた。

コード書いてみると思ったより書けないし実装の難しさを知る

平衡2分探索木を書いてるのに全然操作がO(log n)どころかO(n)でさえないみたいな・・・とか

#### 書いてみて色々

とにかく落ちる。すぐ segmentation fault 超イライラする。

ポインタなんてわかってたつもりだったけどいざ操作するとなるとあんまりわかってないものだった。

最初はmalloc一切使わずに関数の中で変数宣言してそのアドレスを返す、みたいなことしてた....


未だに木をpretty printする関数がうまく書けてなくて、それで序盤はデバッグができなくてアレだった

途中でつら、と思ってcunit入れて適当なテストでなんとかするようにした。

cunitはcunitで失敗しても想定と違って値はなんだったのかが表示されないのでちょっとやりにくい。

回転は最後の最後までバグってた。

昔から場合分けが苦手。数学で必要十分に場合分けができなくて解くのに時間がかかったり解けなかったり、数学苦手だったのを思い出した。

これはアカン。


辞書が実装できて100万件くらいのsetを試してみると終わらないのね。

10万件で30秒かかってた。

profilerで見てみると（ここで Instruments を知る)、 bias を計算するために何度も何度も木の高さを計算しているところが遅い。

この時木の高さは毎回再帰的に計算してた・・・

そりゃ遅いわ・・・


ということで木の高さを構造体で持つようにして、insert後に必要なときに再計算するようにした。

こうするとまたいろんなバグが露呈したがおかげでちゃんと直せた。

「必要なときに再計算」にするというのは速度求めるうえで必須だろうけど「必要なとき」を適切に考えるのが非常に難しいなと

まぁそれで高速化して、10万件で30秒≒100万件で300秒から、100万件で2秒未満とかなり高速化できた。(それでも超遅いのに変わりはないが)

メモリはそれなりに食う。100万件のsetするテストで60MB超

mallocを至るところでやってるけど、実行時間の26%はmallocらしいのでなるほどmalloc遅いんだなと。

自分で書くとやっと実感を持って色々想像できるようになるというか、腑に落ちるというか。

書かなくてもこうなれればいいんだが
